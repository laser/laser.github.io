<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>Erin Swenson-Healey</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
<h1 id="hanging-up-on-callbacks-generators-in-ecmascript-6">Hanging up
on Callbacks: Generators in ECMAScript 6</h1>
<blockquote>
<p>December 1, 2013</p>
</blockquote>
<p>I hear people whine about asynchronous callbacks in JavaScript
constantly. I admit that wrapping your head around control flow in the
World of JavaScript (also known as “Callback Hell” or the “The Pyramid
of Doom” by aforementioned whiners) can be a bit of a mind-explosion if
you’re used to a top-down, synchronous programming style. “Just deal
with it” has been my go-to response; after all, do we expect programming
in all languages to look and feel the same? Of course not.</p>
<p>This all changed after a recent review of the the ECMAScript 6 Draft,
which describes generators – a language feature that will greatly change
the way we write both server and client-side JavaScript. With
generators, we can transform nested callbacks into easy-to-read top
down-style code without blocking our single event loop thread. An
example (adapted from a blog post by Toby Ho), to illustrate my
point:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">setTimeout</span>(<span class="kw">function</span>(){</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_get</span>(<span class="st">&quot;/something.ajax?greeting&quot;</span><span class="op">,</span> <span class="kw">function</span>(err<span class="op">,</span> greeting) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (err) { <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err)<span class="op">;</span> <span class="cf">throw</span> err<span class="op">;</span> }</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">_get</span>(<span class="st">&quot;/else.ajax?who&amp;greeting=&quot;</span><span class="op">+</span>greeting<span class="op">,</span> <span class="kw">function</span>(err<span class="op">,</span> who) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (err) { <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err)<span class="op">;</span> <span class="cf">throw</span> err<span class="op">;</span> }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(greeting<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>who)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        })<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></span></code></pre></div>
<p>…could be written as:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sync</span>(<span class="kw">function</span><span class="op">*</span> (resume) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> (e) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">yield</span> <span class="pp">setTimeout</span>(resume<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> greeting <span class="op">=</span> <span class="kw">yield</span> <span class="fu">_get</span>(<span class="st">&#39;/something.ajax?greeting&#39;</span><span class="op">,</span> resume)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> who <span class="op">=</span> <span class="kw">yield</span> <span class="fu">_get</span>(<span class="st">&#39;/else.ajax?who&amp;greeting=&#39;</span> <span class="op">+</span> greeting<span class="op">,</span> resume)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(greeting <span class="op">+</span> <span class="st">&#39; &#39;</span> <span class="op">+</span> who)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> (e) {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(e)<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> e<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Interesting stuff, right? Centralized exception handling and a
easy-to-understand flow control. Note: If you just have to know how
“sync” is implemented, scroll to the “Blocking Ajax” example below.</p>
<h2 id="uhhh-ecmascript-6">Uhhh, ECMAScript 6?</h2>
<p>The examples in this document work in Chrome Canary version
33.0.1716.0. With the exception of the XHR examples, they should all
work in Node.js with the “–harmony” flag. The generator implementation
provided by JavaScript 1.7+ does not adhere to the ECMAScript 6 draft –
so you’ll have to make some changes in order to get my examples to work
in Firefox. If you want to see these examples running in a browser
(Canary), you can do so here.</p>
<h2 id="es6-generators-quick-n-drrty">ES6 Generators: Quick n’
Drrty</h2>
<p>In order to understand what’s going on in the example above, we need
to talk about what an ES6 Generator is and what it provides you.</p>
<p>According to the ECMAScript 6 Draft, generators are “First-class
coroutines, represented as objects encapsulating suspended execution
contexts.” For those of you who prefer a little less specificity in
their tea: Generators are functions that can suspend themselves (using
the yield keyword) and be resumed (from the outside world) by calling
their “next” method. From your perspective, the JavaScript engine is
still doing only one thing at a time – but it’s now able to suspend
execution in the middle of a (generator) function body and
context-switch to do something else. Generators aren’t enabling
parallelism and they don’t have anything to do with threads.</p>
<h2 id="a-modest-iterator">A Modest Iterator</h2>
<p>Whew. Now that we’ve gotten that out of the way, let’s see some code.
We’ll build a simple iterator to demonstrate the suspend / resume
semantics:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="op">*</span> <span class="fu">fibonacci</span>() {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">yield</span> a<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      c <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      b <span class="op">=</span> c <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">run</span>() {</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">var</span> seq <span class="op">=</span> <span class="fu">fibonacci</span>()<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 0</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 2</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 3</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>   <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(seq<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// 5</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="fu">run</span>()<span class="op">;</span></span></code></pre></div>
<p>Here’s what’s happening:</p>
<ol type="1">
<li>The caller, function “run,” first initializes the fibonacci
generator (denoted by the “function*” syntax). Unlike a normal function,
this does not cause the code in its body to be run – it simply returns a
new generator object.</li>
<li>When “run” calls the generator’s “next” method (a synchronous
operation), the code is the generator’s body run… up until the “yield”
keyword.</li>
<li>Evaluating the “yield” operator suspends the generator and yields
the generator’s result back to the caller. Operations following the
yield have not yet been evaluated. The value (the operand, “a” of
“yield”) will be accessible to the caller through the “value” property
of the generator result.</li>
<li>When the caller is ready to resume the generator, the “next” method
is called and processing the code in the generator’s body
continues<br />
immediately after where the prior “yield” left-off. You may be wondering
if the generator function will ever return. The answer is “no,” it will
loop as many times as someone calls the “next” method.</li>
</ol>
<h2 id="following-the-flow-a-digression">Following the Flow: A
Digression</h2>
<p>As mentioned in the prior example, code in the generator function’s
body encountered after the yield operation won’t be run until the
generator is resumed. The generator can also be passed an argument,
which will be substituted into the generator’s function body where yield
left off:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="op">*</span> <span class="fu">powGenerator</span>() {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> result <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">pow</span>(<span class="kw">yield</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="kw">yield</span> <span class="st">&quot;b&quot;</span>)<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> g <span class="op">=</span> <span class="fu">powGenerator</span>()<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(g<span class="op">.</span><span class="fu">next</span>()<span class="op">.</span><span class="at">value</span>)<span class="op">;</span>   <span class="co">// &quot;a&quot;, from the first yield</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(g<span class="op">.</span><span class="fu">next</span>(<span class="dv">10</span>)<span class="op">.</span><span class="at">value</span>)<span class="op">;</span> <span class="co">// &quot;b&quot;, from the second</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(g<span class="op">.</span><span class="fu">next</span>(<span class="dv">2</span>)<span class="op">.</span><span class="at">value</span>)<span class="op">;</span>  <span class="co">// 100, the result</span></span></code></pre></div>
<p>The first time the generator’s body is run, “a” is yielded back to
the caller (and made available through the “value” property of the
returned object). The caller then resumes the generator, passing 10.
Using substitution to visualize what’s happening:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="op">*</span> <span class="fu">powGenerator</span>() {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> result <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">pow</span>(<span class="op">----</span><span class="dv">10</span><span class="op">----,</span> <span class="kw">yield</span> <span class="st">&quot;b&quot;</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The generator then hits the second “yield” statement and is
suspended. The value “b” is available on the returned object. Finally,
the caller resumes the generator, passing 2. With substitution:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="op">*</span> <span class="fu">powGenerator</span>() {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> result <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">pow</span>(<span class="op">----</span><span class="dv">10</span><span class="op">----,</span> <span class="op">----</span><span class="dv">2</span><span class="op">----</span>)<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The “pow” method is then called and the return value stored in the
“result” variable which is then returned to the caller.</p>
<h2 id="fake-synchronicity-blocking-ajax">Fake Synchronicity: Blocking
Ajax</h2>
<p>Fibonacci sequence-emitting iterators and math functions with
multiple entry points are interesting, sure – but I promised to show you
a way to eliminate callback functions from your otherwise-callback-heavy
JavaScript code. As it turns out, we can pick from what I’ve already
showed you some patterns that will get us most of the way there.</p>
<p>Before we jump into the next example, note the “sync” function. This
function calls the generator function with a resume function, and then
calls “next” on it to get things started. Whenever the generator
function needs an async call, it supplies resume as the callback and
yields. When the async call executes resume, it calls “next” (with a
value) on the generator, allowing it to continue execution with the
result of the async call.</p>
<p>Okay, back to the codez:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// **************</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">// framework code</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sync</span>(gen) {</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> iterable<span class="op">,</span> resume<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  resume <span class="op">=</span> <span class="kw">function</span>(err<span class="op">,</span> retVal) {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (err) iterable<span class="op">.</span><span class="fu">raise</span>(err)<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    iterable<span class="op">.</span><span class="fu">next</span>(retVal)<span class="op">;</span> <span class="co">// resume!  </span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  iterable <span class="op">=</span> <span class="fu">gen</span>(resume)<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  iterable<span class="op">.</span><span class="fu">next</span>()<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">_get</span>(url<span class="op">,</span> callback) {</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> x <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  x<span class="op">.</span><span class="at">onreadystatechange</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x<span class="op">.</span><span class="at">readyState</span> <span class="op">==</span> <span class="dv">4</span>) {</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>      <span class="fu">callback</span>(<span class="kw">null</span><span class="op">,</span> x<span class="op">.</span><span class="at">responseText</span>)<span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  x<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  x<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co">// ****************</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="co">// application code</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="fu">sync</span>(<span class="kw">function</span><span class="op">*</span> (resume) {</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span>(<span class="st">&#39;foo&#39;</span>)<span class="op">;</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> resp <span class="op">=</span> <span class="kw">yield</span> <span class="fu">_get</span>(<span class="st">&quot;blix.txt&quot;</span><span class="op">,</span> resume)<span class="op">;</span> <span class="co">// suspend!</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span>(resp)<span class="op">;</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span>(<span class="st">&#39;bar&#39;</span>)<span class="op">;</span> <span class="co">// not part of our generator function’s body</span></span></code></pre></div>
<p>Can you guess what you’re going to see in the console? If you said
“foo,” “bar”, and “whatever was in blix.txt,” felicidades, compa. You’re
right. By putting the code that we want to run in series inside a
suspendable generator function, we can make it behave in a synchronous,
top-to-bottom manner. We aren’t blocking the event loop thread; we
suspend the generator and resume the non-generator code at the point at
which we called “next.” The generator has been suspended but has not
been garbage collected. The callback, called at some point in the future
on a different tick of the event loop, resumes our generator, passing a
value.</p>
<h2 id="centralized-exception-handling">Centralized Exception
Handling</h2>
<p>Centralizing exception handling across various asynchronous callback
functions is a pain. Take, for example, the following:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">firstAsync</span>(<span class="kw">function</span>(err<span class="op">,</span> a) {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (err) { <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err)<span class="op">;</span> <span class="cf">throw</span> err<span class="op">;</span> }</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">secondAsync</span>(<span class="kw">function</span>(err<span class="op">,</span> b) {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (err) { <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err)<span class="op">;</span> <span class="cf">throw</span> err<span class="op">;</span> }</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">thirdAsync</span>(<span class="kw">function</span>(err<span class="op">,</span> c) {</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (err) { <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err)<span class="op">;</span> <span class="cf">throw</span> err<span class="op">;</span> }</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">callback</span>(a<span class="op">,</span> b<span class="op">,</span> c)<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      })<span class="op">;</span>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span> </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> (e) {</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(e)<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The catch block will never be hit (unless for some reason the
synchronous calls to “firstAsync” or “secondAsync” or “thirdAsync” cause
an error to be thrown) due to the execution of the callback being a part
of a completely different call stack, on a separate tick of the event
loop. Exception handling must be done in the callback body itself. One
could write higher-order functions to eliminate some of the
error-throwing duplication and remove some of the nesting with a library
like async, but if we follow the Node.js error as “first argument”
convention, we can write a generalized handler that will propagate all
errors back to the generator:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sync</span>(gen) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">var</span> iterable<span class="op">,</span> resume<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>   resume <span class="op">=</span> <span class="kw">function</span>(err<span class="op">,</span> retVal) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (err) iterable<span class="op">.</span><span class="fu">raise</span>(err)<span class="op">;</span> <span class="co">// raise!</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>      iterable<span class="op">.</span><span class="fu">next</span>(retVal)<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>   }<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>   iterable <span class="op">=</span> <span class="fu">gen</span>(resume)<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>   iterable<span class="op">.</span><span class="fu">next</span>()<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="fu">sync</span>(<span class="kw">function</span><span class="op">*</span> (resume) {</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">try</span> {</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">var</span> x <span class="op">=</span> <span class="fu">firstAsync</span>(resume)<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">var</span> y <span class="op">=</span> <span class="fu">secondAsync</span>(resume)<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">var</span> z <span class="op">=</span> <span class="fu">thirdAsync</span>(resume)<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">// … do something with your data</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>   <span class="cf">catch</span> (e) {</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>      <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(e)<span class="op">;</span> <span class="co">// will catch errors from any of the three calls</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Now an error thrown inside any of these three calls will be caught by
the single catch block. And – just like in the vanilla JavaScript
example – an exception thrown from inside of any of the three calls will
prevent the subsequent functions from being called. Very nice.</p>
<h2 id="concurrent-operations">Concurrent Operations</h2>
<p>Just because your generator code runs from top-to-bottom doesn’t mean
you can’t handle multiple asynchronous operations concurrently.
Libraries like genny and gen-run and co provide APIs do this, and
basically reduce to yielding some enumeration of asynchronous operations
to be completed before the generator is to be resumed. We can add basic
support for concurrent operations to our sync method like so:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sync</span>(gen) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> iterable<span class="op">,</span> resume<span class="op">,</span> check<span class="op">,</span> vals<span class="op">,</span> ops<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  vals <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  ops  <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  check <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (vals<span class="op">.</span><span class="at">length</span> <span class="op">==</span> ops) {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (ops <span class="op">==</span> <span class="dv">1</span>) { </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        iterable<span class="op">.</span><span class="fu">next</span>(vals[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> {</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        iterable<span class="op">.</span><span class="fu">next</span>(vals)<span class="op">;</span> <span class="co">// resume with an array</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  resume <span class="op">=</span> <span class="kw">function</span>(err<span class="op">,</span> retVal) {</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> slot <span class="op">=</span> ops<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    ops<span class="op">++;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">function</span>(err<span class="op">,</span> retVal) {</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (err) { </span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        iterable<span class="op">.</span><span class="fu">raise</span>(err)<span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> {</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        vals[slot] <span class="op">=</span> retVal<span class="op">;</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">check</span>()<span class="op">;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  iterable <span class="op">=</span> <span class="fu">gen</span>(resume)<span class="op">;</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  iterable<span class="op">.</span><span class="fu">next</span>()<span class="op">;</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>…which then requires us to invoke the resume function, passing its
result as the callback to our asynchronous operation:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sync</span>(<span class="kw">function</span><span class="op">*</span> (resume) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> oneAndTwo <span class="op">=</span> <span class="kw">yield</span> [<span class="fu">_get</span>(<span class="st">&quot;test1.txt&quot;</span><span class="op">,</span> <span class="fu">resume</span>())<span class="op">,</span> <span class="fu">_get</span>(<span class="st">&quot;test2.txt&quot;</span><span class="op">,</span> <span class="fu">resume</span>())]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> three     <span class="op">=</span> <span class="kw">yield</span> <span class="fu">_get</span>(<span class="st">&quot;test3.txt&quot;</span><span class="op">,</span> <span class="fu">resume</span>())</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span>(oneAndTwo[<span class="dv">0</span>] <span class="op">+</span> <span class="st">&quot; - &quot;</span> <span class="op">+</span> oneAndTwo[<span class="dv">1</span>] <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> three)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Asynchronous callbacks as a programming style has been the de-facto
JavaScript pattern for a long while – but the with the introduction of
generators in the browser (Firefox since JavaScript 1.7 and Chrome
Canary as of a few months ago), it doesn’t have to stay that way.
Leveraging the new control flow constructs provided by generators can
enable a very different coding style – one which I think will evolve to
contend with the nested-callback style – as the ECMAScript 6 standard is
implemented by the JavaScript engines of tomorrow.</p>
</body>
</html>